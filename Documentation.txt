Documentation:
    Our solution algorithm for this problem utilizes a non-binary heap (referred to as a battle heap in the code)
    to keep track of the index of the largest unprocessed value in the private array. As such, our algorithm 
    can be analysed in two stages: an initial heap building stage, and a max-element retrieval stage. 
    
    In the first stage, elements are iteratively paired up and compared against each other. Elements who win will 
    live on to be compared against other surviving elements in the next round. Losing elements are removed from 
    consideration, and, in the heap, become a child of the element that beat it. If there is an odd number of 
    elements in a round, then the left-out element gets a bye this round. This tournament continues until there is 
    a single node left standing, which becomes the root. This tournament builds the heap while takes exactly 
    n - 1 comparisons.

    The second stage, is about removing the largest element and then finding the next largest to take its place. When
    a removal occurs, the root is removed from the heap, and a tournament, as described in the previous phase, 
    is held on the children. The winner of this tournament becomes the new root. This phase happens in m - 1 
    comparisons where m is the number of children the root had. This stage is performed k - 1 times, as the kth largest
    element does not need to be removed from the heap.

Theoretical WC:
    Stage 1:
    In the theoretical worst case, there are ceil(lg(n)) rounds of the tournament with ceil(n/(2^round#))
    comparisons during a round. Analysis issues occur when there is an odd number of competitors in the round.
    We theorize the worst case occurs when n=2^k - 1 for some positive integer k. This results in a maximal number of odd 
    competitors during the tournament. 
    We theorize the exact number of comparisons is: Sum from i = 1 to ceil(lgn) of (floor(n/2^i) + floor(n/2^i)%2).
    The intution behind this is as follows:
    
    The second term accounts for odd competitors during rounds of the tournament.

    Stage 2:
    The worst case for our initial tournament results in ceil(lgn)-1 children of the root.
    Thus each removal and merge trees event takes ceil(lgn)-1 + floor(lglg(n)) comparisons with n decreasing
    by one each removal.

Theoretical Expected WC:
    Stage 1 of our algorithm always takes n-1 comparisons when n is {100, 10000}.
    Stage 2 takes takes lgn comparisons per root removal resulting in k*lgn comparisons.

Theoretical AVG:
    Stage 1 of our algorithm always takes the same number of comparisons for a given n. For any value of n, our summation results in n-1.
    The resulting heap can vary and this risks affecting the number of comparisons.
    For example, if there is an odd man out in the last round of the tournament, that index
    has a 1/10000 chance of "winning" against the root. If he wins, it costs 0 comparisons to merge the tree after the first removal.
    However, rare events like this do little to effect our average case.
    On average, the number of children the root has is expected to stay around ceil(lg(n)).
    When n=100, this is ~7 nodes. The cost of merging 7 trees into a heap in a tournament is 3 + 2 + 1 = 6 comparisons. With k=10, 10*6 = 60.
    When n=10,000, this is ~14 nodes. The cost of merging 14 trees is 7 + 3 + 2 + 1 = 13. With k=40, 13*40 = 520.
    Using this, our theoretical avg number of comparisons is  99 + 60 = 159 for n=100, k=10.
    For k=10,000 n=40, our theoretical avg number of comparisons is 99,999 + 520 = 10519.

Analysis for observed WC:
    Results:
    n=  100,  k=10:  maximum= 168,  avg=  158.14
    n=10000,  k=40:  maximum= 10627,  avg=10592.06
    Our worst cases match nearly exactly with n + k lg n.
    Theoretical:
    99 + 10lg(100) = 159
    9999 + 40lg(10000) = 10519
    We expected the cost of merging to increase slowly as more elements are removed from the heap.
    
